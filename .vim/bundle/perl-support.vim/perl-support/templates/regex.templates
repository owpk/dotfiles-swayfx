
== LIST: POSIX_CharClasses == list ==
  'alnum',
  'alpha',
  'ascii',
  'blank',
  'cntrl',
  'digit',
  'graph',
  'lower',
  'print',
  'punct',
  'space',
  'upper',
  'word',
  'xdigit',
== ENDLIST ==

== Regex.POSIX classes == expandmenu, insert, sc:p, map:xpc ==
|PickList( 'POSIX char. classes', 'POSIX_CharClasses' )|
[:|PICK|:]<CURSOR>
== ENDTEMPLATE ==

== LIST: UnicodeProperties == hash ==
  'Letter L'                        : 'Letter',
  'Lowercase_Letter Ll'             : 'Lowercase_Letter',
  'Uppercase_Letter Lu'             : 'Uppercase_Letter',
  'Titlecase_Letter Lt'             : 'Titlecase_Letter',
  'Modifier_Letter Lm'              : 'Modifier_Letter',
  'Other_Letter Lo'                 : 'Other_Letter',
  'Mark M'                          : 'Mark',
  'Non_Spacing_Mark Mn'             : 'Non_Spacing_Mark',
  'Spacing_Combining_Mark M'        : 'Spacing_Combining_Mark',
  'Enclosing_Mark Me'               : 'Enclosing_Mark',
  'Separator Z'                     : 'Separator',
  'Space_Separator Zs'              : 'Space_Separator',
  'Line_Separator Zl'               : 'Line_Separator',
  'Paragraph_Separator Zp'          : 'Paragraph_Separator',
  'Symbol S'                        : 'Symbol',
  'Math_Symbol Sm'                  : 'Math_Symbol',
  'Currency_Symbol Sc'              : 'Currency_Symbol',
  'Modifier_Symbol Sk'              : 'Modifier_Symbol',
  'Other_Symbol So'                 : 'Other_Symbol',
  'Number N'                        : 'Number',
  'Decimal_Digit_Number Nd'         : 'Decimal_Digit_Number',
  'Letter_Number Nl'                : 'Letter_Number',
  'Other_Number No'                 : 'Other_Number',
  'Punctuation P'                   : 'Punctuation',
  'Dash_Punctuation Pd'             : 'Dash_Punctuation',
  'Open_Punctuation Ps'             : 'Open_Punctuation',
  'Close_Punctuation Pe'            : 'Close_Punctuation',
  'Initial_Punctuation Pi'          : 'Initial_Punctuation',
  'Final_Punctuation Pf'            : 'Final_Punctuation',
  'Connector_Punctuation Pc'        : 'Connector_Punctuation',
  'Other_Punctuation Po'            : 'Other_Punctuation',
  'Other C'                         : 'Other',
  'Control Cc'                      : 'Control',
  'Format Cf'                       : 'Format',
  'Private_Use Co'                  : 'Private_Use',
  'Unassigned Cn'                   : 'Unassigned',
== ENDLIST ==

== Regex.Unicode Property == expandmenu, insert, sc:u, map:xup ==
|PickList( 'Unicode Property', 'UnicodeProperties' )|
\p{|PICK|}<CURSOR>
== ENDTEMPLATE ==


== LIST: ExtendedRegex == hash ==
  'comment'                  : '(?#<SPLIT><CURSOR>)',
  'cluster only parenthesis' : '(?-imsx:<SPLIT><CURSOR>)',
  'named capture'            : '(?<<SPLIT><CURSOR>>)',
  'pattern modifier'         : '<SPLIT>(?<CURSOR>-imsx)',
  'execute code'             : '(?{<SPLIT><CURSOR>})',
  'match regex from code'    : '(??{<SPLIT><CURSOR>})',
  'match-if-then'            : '(?(<SPLIT><CURSOR>))',
  'match-if-then-else'       : '(?(<SPLIT><CURSOR>)|)',
  'lookahead succeeds'       : '(?=<SPLIT><CURSOR>)',
  'lookahead fails'          : '(?!<SPLIT><CURSOR>)',
  'lookbehind succeeds'      : '(?<=<SPLIT><CURSOR>)',
  'lookbehind fails'         : '(?<!<SPLIT><CURSOR>)',
  'prohibit backtracking'    : '(?><SPLIT><CURSOR>)',
== ENDLIST ==

== Regex.extended Regex == expandmenu, insert, visual, sc:e, map:xex ==
|PickList( 'Regex, extended', 'ExtendedRegex' )|
|PICK|
== ENDTEMPLATE ==

§§== Regex.grouping == insert ==
§§(<SPLIT><CURSOR>)
§§== Regex.alternation == insert ==
§§(<SPLIT><CURSOR>|)
§§== Regex.char class == insert ==
§§[<SPLIT><CURSOR>]
§§== Regex.count == insert ==
§§{<SPLIT><CURSOR>,}
§§== ENDTEMPLATE ==

== LIST: Metasymbols == hash ==
'word boundary \\b'           : '\b<CURSOR>',
'digit \\d'                   : '\d<CURSOR>',
'whitespace \\s'              : '\s<CURSOR>',
'word character \\w'          : '\w<CURSOR>',
'match property \\p{}'        : '\p{<SPLIT><CURSOR>}',
'non-word boundary \\B'       : '\B<CURSOR>',
'non-digit \\D'               : '\D<CURSOR>',
'non-whitespace \\S'          : '\S<CURSOR>',
'non-word character \\W'      : '\W<CURSOR>',
'do not match property \\P{}' : '\P{<SPLIT><CURSOR>}',
== ENDLIST ==

== Regex.metasymbols == expandmenu, insert, sc:m, map:xms ==
|PickList( 'Metasymbols', 'Metasymbols' )|
|PICK|
== ENDTEMPLATE ==

